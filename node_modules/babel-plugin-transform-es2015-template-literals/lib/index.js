"use strict";

exports.__esModule = true;

exports.default = function (_ref) {
  var t = _ref.types;

  return {
    visitor: {
      TaggedTemplateExpression: function TaggedTemplateExpression(path, state) {
        var node = path.node;
        var quasi = node.quasi;


        var strings = [];
        var raws = [];

        for (var _iterator = quasi.quasis, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
          var _ref2;

          if (_isArray) {
            if (_i >= _iterator.length) break;
            _ref2 = _iterator[_i++];
          } else {
            _i = _iterator.next();
            if (_i.done) break;
            _ref2 = _i.value;
          }

          var elem = _ref2;
          var _elem$value = elem.value,
              raw = _elem$value.raw,
              cooked = _elem$value.cooked;

          var value = cooked == null ? path.scope.buildUndefinedNode() : t.stringLiteral(cooked);

          strings.push(value);
          raws.push(t.stringLiteral(raw));
        }

        var templateName = "taggedTemplateLiteral";
        if (state.opts.loose) templateName += "Loose";

        var templateObject = state.file.addTemplateObject(templateName, t.arrayExpression(strings), t.arrayExpression(raws));

        var args = [templateObject].concat(quasi.expressions);

        path.replaceWith(t.callExpression(node.tag, args));
      },
      TemplateLiteral: function TemplateLiteral(path, state) {
        var nodes = [];
        var expressions = path.get("expressions");

        var index = 0;
        for (var _iterator2 = path.node.quasis, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator]();;) {
          var _ref3;

          if (_isArray2) {
            if (_i2 >= _iterator2.length) break;
            _ref3 = _iterator2[_i2++];
          } else {
            _i2 = _iterator2.next();
            if (_i2.done) break;
            _ref3 = _i2.value;
          }

          var elem = _ref3;

          if (elem.value.cooked) {
            nodes.push(t.stringLiteral(elem.value.cooked));
          }

          if (index < expressions.length) {
            var expr = expressions[index++];
            var node = expr.node;
            if (state.opts.spec && !expr.isBaseType("string") && !expr.isBaseType("number")) {
              nodes.push(t.callExpression(t.identifier("String"), [node]));
            } else if (!t.isStringLiteral(node, { value: "" })) {
              nodes.push(node);
            }
          }
        }

        if (!t.isStringLiteral(nodes[0]) && !t.isStringLiteral(nodes[1])) {
          nodes.unshift(t.stringLiteral(""));
        }

        var root = nodes[0];
        for (var i = 1; i < nodes.length; i++) {
          root = t.binaryExpression("+", root, nodes[i]);
        }

        path.replaceWith(root);
      }
    }
  };
};